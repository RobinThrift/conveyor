// Code generated by sqlc. DO NOT EDIT.

import type { Database } from "./db"

import { mapRowToObj, numberToBool } from "./utils"

import { dateFromSQLite, dateToSQLite } from "@/storage/database/sqlite/types/datetime"

const getMemoQuery = `-- name: GetMemo :one
SELECT public_id, content, is_archived, is_deleted, created_at, updated_at
FROM memos
WHERE public_id = ?
LIMIT 1`

export interface GetMemoArgs {
    publicId: string
}

export interface GetMemoRow {
    publicId: string
    content: Uint8Array<ArrayBufferLike>
    isArchived: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
}

export async function getMemo(
    database: Database,
    args: GetMemoArgs,
    abort?: AbortSignal,
): Promise<GetMemoRow | null> {
    let result = await database.queryOne(getMemoQuery, [args.publicId], abort)
    if (result === undefined) {
        return null
    }
    return mapRowToObj<GetMemoRow>(result, {
        isArchived: numberToBool,
        isDeleted: numberToBool,
        createdAt: dateFromSQLite,
        updatedAt: dateFromSQLite,
    })
}

const listMemosQuery = `-- name: ListMemos :many
SELECT public_id, content, is_archived, is_deleted, created_at, updated_at
FROM memos
WHERE
    CASE WHEN ?1 IS NOT NULL THEN created_at < datetime(?1) ELSE true END
    AND CASE WHEN CAST(?2 AS BOOLEAN) THEN date(created_at) = date(?3) ELSE true END
    AND CASE WHEN CAST(?4 AS BOOLEAN) THEN date(created_at) <= date(?5) ELSE true END
    AND CASE WHEN CAST(?6 AS BOOLEAN) THEN is_archived = CAST(?7 AS BOOLEAN) ELSE is_archived = false END
    AND CASE WHEN CAST(?8 AS BOOLEAN) THEN is_deleted = CAST(?9 AS BOOLEAN) ELSE is_deleted = false END
ORDER BY created_at DESC
LIMIT ?10`

export interface ListMemosArgs {
    pageAfter: Date | undefined
    withCreatedAt: boolean
    createdAt: any
    withCreatedAtOrOlder: boolean
    createdAtOrOlder: any
    withIsArchived: boolean
    isArchived: boolean
    withIsDeleted: boolean
    isDeleted: boolean
    pageSize: number
}

export interface ListMemosRow {
    publicId: string
    content: Uint8Array<ArrayBufferLike>
    isArchived: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
}

export async function listMemos(
    database: Database,
    args: ListMemosArgs,
    abort?: AbortSignal,
): Promise<ListMemosRow[]> {
    let result = await database.query(
        listMemosQuery,
        [
            dateToSQLite(args.pageAfter),
            args.withCreatedAt,
            args.createdAt,
            args.withCreatedAtOrOlder,
            args.createdAtOrOlder,
            args.withIsArchived,
            args.isArchived,
            args.withIsDeleted,
            args.isDeleted,
            args.pageSize,
        ],
        abort,
    )
    return result.map((row) =>
        mapRowToObj<ListMemosRow>(row, {
            isArchived: numberToBool,
            isDeleted: numberToBool,
            createdAt: dateFromSQLite,
            updatedAt: dateFromSQLite,
        }),
    )
}

const listMemosForTagQuery = `-- name: ListMemosForTag :many
SELECT memos.public_id, memos.content, memos.is_archived, memos.is_deleted, memos.created_at, memos.updated_at FROM memos
JOIN memo_tags ON memo_id = memos.public_id
WHERE
    CASE WHEN ?1 IS NOT NULL THEN memos.created_at < datetime(?1) ELSE true END
    AND memo_tags.tag = ?2
    AND CASE WHEN CAST(?3 AS BOOLEAN) THEN date(memos.created_at) = date(?4) ELSE true END
    AND CASE WHEN CAST(?5 AS BOOLEAN) THEN date(memos.created_at) <= date(?6) ELSE true END
    AND CASE WHEN CAST(?7 AS BOOLEAN) THEN is_archived = CAST(?8 AS BOOLEAN) ELSE is_archived = false END
    AND CASE WHEN CAST(?9 AS BOOLEAN) THEN is_deleted = CAST(?10 AS BOOLEAN) ELSE is_deleted = false END
ORDER BY memos.created_at DESC
LIMIT ?11`

export interface ListMemosForTagArgs {
    pageAfter: Date | undefined
    tag: string
    withCreatedAt: boolean
    createdAt: any
    withCreatedAtOrOlder: boolean
    createdAtOrOlder: any
    withIsArchived: boolean
    isArchived: boolean
    withIsDeleted: boolean
    isDeleted: boolean
    pageSize: number
}

export interface ListMemosForTagRow {
    publicId: string
    content: Uint8Array<ArrayBufferLike>
    isArchived: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
}

export async function listMemosForTag(
    database: Database,
    args: ListMemosForTagArgs,
    abort?: AbortSignal,
): Promise<ListMemosForTagRow[]> {
    let result = await database.query(
        listMemosForTagQuery,
        [
            dateToSQLite(args.pageAfter),
            args.tag,
            args.withCreatedAt,
            args.createdAt,
            args.withCreatedAtOrOlder,
            args.createdAtOrOlder,
            args.withIsArchived,
            args.isArchived,
            args.withIsDeleted,
            args.isDeleted,
            args.pageSize,
        ],
        abort,
    )
    return result.map((row) =>
        mapRowToObj<ListMemosForTagRow>(row, {
            isArchived: numberToBool,
            isDeleted: numberToBool,
            createdAt: dateFromSQLite,
            updatedAt: dateFromSQLite,
        }),
    )
}

const listMemosWithSearchQuery = `-- name: ListMemosWithSearch :many
SELECT public_id, content, is_archived, is_deleted, created_at, updated_at
FROM memos_fts
WHERE
    CASE WHEN ?1 IS NOT NULL THEN created_at < datetime(?1) ELSE true END
    AND content MATCH CAST(?2 as TEXT)
    AND CASE WHEN CAST(?3 as BOOLEAN) THEN date(created_at) = date(?4) ELSE true END
    AND CASE WHEN CAST(?5 as BOOLEAN) THEN date(created_at) <= date(?6) ELSE true END
    AND CASE WHEN CAST(?7 AS BOOLEAN) THEN is_archived = CAST(?8 AS BOOLEAN) ELSE is_archived = false END
    AND CASE WHEN CAST(?9 AS BOOLEAN) THEN is_deleted = CAST(?10 AS BOOLEAN) ELSE is_deleted = false END
ORDER BY created_at DESC, rank
LIMIT ?11`

export interface ListMemosWithSearchArgs {
    pageAfter: Date | undefined
    search: string
    withCreatedAt: boolean
    createdAt: any
    withCreatedAtOrOlder: boolean
    createdAtOrOlder: any
    withIsArchived: boolean
    isArchived: boolean
    withIsDeleted: boolean
    isDeleted: boolean
    pageSize: number
}

export interface ListMemosWithSearchRow {
    publicId: string
    content: Uint8Array<ArrayBufferLike>
    isArchived: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
}

export async function listMemosWithSearch(
    database: Database,
    args: ListMemosWithSearchArgs,
    abort?: AbortSignal,
): Promise<ListMemosWithSearchRow[]> {
    let result = await database.query(
        listMemosWithSearchQuery,
        [
            dateToSQLite(args.pageAfter),
            args.search,
            args.withCreatedAt,
            args.createdAt,
            args.withCreatedAtOrOlder,
            args.createdAtOrOlder,
            args.withIsArchived,
            args.isArchived,
            args.withIsDeleted,
            args.isDeleted,
            args.pageSize,
        ],
        abort,
    )
    return result.map((row) =>
        mapRowToObj<ListMemosWithSearchRow>(row, {
            createdAt: dateFromSQLite,
            updatedAt: dateFromSQLite,
        }),
    )
}

const listMemosForTagWithSearchQuery = `-- name: ListMemosForTagWithSearch :many
SELECT memos_fts.public_id, memos_fts.content, memos_fts.is_archived, memos_fts.is_deleted, memos_fts.created_at, memos_fts.updated_at FROM memos_fts
JOIN memo_tags ON memo_id = memos_fts.public_id
WHERE
    CASE WHEN ?1 IS NOT NULL THEN memos_fts.created_at < datetime(?1) ELSE true END
    AND memo_tags.tag = ?2
    AND content MATCH CAST(?3 as TEXT)
    AND CASE WHEN CAST(?4 as BOOLEAN) THEN date(memos_fts.created_at) = date(?5) ELSE true END
    AND CASE WHEN CAST(?6 as BOOLEAN) THEN date(memos_fts.created_at) <= date(?7) ELSE true END
    AND CASE WHEN CAST(?8 AS BOOLEAN) THEN is_archived = CAST(?9 AS BOOLEAN) ELSE is_archived = false END
    AND CASE WHEN CAST(?10 AS BOOLEAN) THEN is_deleted = CAST(?11 AS BOOLEAN) ELSE is_deleted = false END
ORDER BY memos_fts.created_at DESC, rank
LIMIT ?12`

export interface ListMemosForTagWithSearchArgs {
    pageAfter: Date | undefined
    tag: string
    search: string
    withCreatedAt: boolean
    createdAt: any
    withCreatedAtOrOlder: boolean
    createdAtOrOlder: any
    withIsArchived: boolean
    isArchived: boolean
    withIsDeleted: boolean
    isDeleted: boolean
    pageSize: number
}

export interface ListMemosForTagWithSearchRow {
    publicId: string
    content: Uint8Array<ArrayBufferLike>
    isArchived: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
}

export async function listMemosForTagWithSearch(
    database: Database,
    args: ListMemosForTagWithSearchArgs,
    abort?: AbortSignal,
): Promise<ListMemosForTagWithSearchRow[]> {
    let result = await database.query(
        listMemosForTagWithSearchQuery,
        [
            dateToSQLite(args.pageAfter),
            args.tag,
            args.search,
            args.withCreatedAt,
            args.createdAt,
            args.withCreatedAtOrOlder,
            args.createdAtOrOlder,
            args.withIsArchived,
            args.isArchived,
            args.withIsDeleted,
            args.isDeleted,
            args.pageSize,
        ],
        abort,
    )
    return result.map((row) =>
        mapRowToObj<ListMemosForTagWithSearchRow>(row, {
            createdAt: dateFromSQLite,
            updatedAt: dateFromSQLite,
        }),
    )
}

const createMemoQuery = `-- name: CreateMemo :one
INSERT INTO memos(
    public_id,
    content,
    created_at
) VALUES (?, ?, ?)
RETURNING public_id`

export interface CreateMemoArgs {
    publicId: string
    content: Uint8Array<ArrayBufferLike>
    createdAt: Date
}

export interface CreateMemoRow {
    publicId: string
}

export async function createMemo(
    database: Database,
    args: CreateMemoArgs,
    abort?: AbortSignal,
): Promise<CreateMemoRow | null> {
    let result = await database.queryOne(
        createMemoQuery,
        [args.publicId, args.content, dateToSQLite(args.createdAt)],
        abort,
    )
    if (result === undefined) {
        return null
    }
    return mapRowToObj<CreateMemoRow>(result, {})
}

const updateMemoContentQuery = `-- name: UpdateMemoContent :execrows
UPDATE memos SET
    content = ?,
    updated_at = strftime('%Y-%m-%d %H:%M:%SZ', CURRENT_TIMESTAMP)
WHERE public_id = ?`

export interface UpdateMemoContentArgs {
    content: Uint8Array<ArrayBufferLike>
    publicId: string
}

export async function updateMemoContent(
    database: Database,
    args: UpdateMemoContentArgs,
    abort?: AbortSignal,
) {
    return database.exec(updateMemoContentQuery, [args.content, args.publicId], abort)
}

const seteMemoArchiveStatusQuery = `-- name: SeteMemoArchiveStatus :execrows
UPDATE memos SET
    is_archived = ?,
    is_deleted = false,
    updated_at = strftime('%Y-%m-%d %H:%M:%SZ', CURRENT_TIMESTAMP)
WHERE public_id = ?`

export interface SeteMemoArchiveStatusArgs {
    isArchived: boolean
    publicId: string
}

export async function seteMemoArchiveStatus(
    database: Database,
    args: SeteMemoArchiveStatusArgs,
    abort?: AbortSignal,
) {
    return database.exec(seteMemoArchiveStatusQuery, [args.isArchived, args.publicId], abort)
}

const setMemoDeletionStatusQuery = `-- name: SetMemoDeletionStatus :execrows
UPDATE memos SET
    is_deleted = ?,
    is_archived = false,
    updated_at = strftime('%Y-%m-%d %H:%M:%SZ', CURRENT_TIMESTAMP)
WHERE public_id = ?`

export interface SetMemoDeletionStatusArgs {
    isDeleted: boolean
    publicId: string
}

export async function setMemoDeletionStatus(
    database: Database,
    args: SetMemoDeletionStatusArgs,
    abort?: AbortSignal,
) {
    return database.exec(setMemoDeletionStatusQuery, [args.isDeleted, args.publicId], abort)
}

const cleanupDeletedMemosQuery = `-- name: CleanupDeletedMemos :execrows
DELETE FROM memos WHERE is_deleted = true AND date(updated_at) < date('now','-30 days')`

export async function cleanupDeletedMemos(database: Database, abort?: AbortSignal) {
    return database.exec(cleanupDeletedMemosQuery, [], abort)
}

const listTagsQuery = `-- name: ListTags :many
SELECT id, tag, count, created_at, updated_at
FROM tags
WHERE tag > ?1
ORDER BY tag ASC
LIMIT ?2`

export interface ListTagsArgs {
    pageAfter: string
    pageSize: number
}

export interface ListTagsRow {
    id: number
    tag: string
    count: any
    createdAt: Date
    updatedAt: Date
}

export async function listTags(
    database: Database,
    args: ListTagsArgs,
    abort?: AbortSignal,
): Promise<ListTagsRow[]> {
    let result = await database.query(listTagsQuery, [args.pageAfter, args.pageSize], abort)
    return result.map((row) =>
        mapRowToObj<ListTagsRow>(row, {
            createdAt: dateFromSQLite,
            updatedAt: dateFromSQLite,
        }),
    )
}

const createTagQuery = `-- name: CreateTag :exec
INSERT INTO tags(
    tag,
    count
) VALUES (?, 1)
ON CONFLICT (tag)
DO UPDATE SET
    updated_at  = strftime('%Y-%m-%d %H:%M:%SZ', CURRENT_TIMESTAMP)`

export interface CreateTagArgs {
    tag: string
}

export async function createTag(database: Database, args: CreateTagArgs, abort?: AbortSignal) {
    await database.exec(createTagQuery, [args.tag], abort)
}

const updateTagCountQuery = `-- name: UpdateTagCount :exec
UPDATE tags SET
    count = (SELECT COUNT(*) FROM memo_tags WHERE memo_tags.tag = tags.tag),
    updated_at  = strftime('%Y-%m-%d %H:%M:%SZ', CURRENT_TIMESTAMP)
WHERE tags.tag in (/*SLICE:tags*/?)`

export interface UpdateTagCountArgs {
    tags: string[]
}

export async function updateTagCount(
    database: Database,
    args: UpdateTagCountArgs,
    abort?: AbortSignal,
) {
    let updateTagCountQueryWithSliceParams = updateTagCountQuery.replace(
        "/*SLICE:tags*/?",
        [...Array(args.tags.length).keys()].map((i) => `?${i + 1}`).join(","),
    )
    await database.exec(updateTagCountQueryWithSliceParams, [...args.tags], abort)
}

const cleanupTagsWithNoCountQuery = `-- name: CleanupTagsWithNoCount :exec
DELETE FROM tags WHERE count = 0`

export async function cleanupTagsWithNoCount(database: Database, abort?: AbortSignal) {
    await database.exec(cleanupTagsWithNoCountQuery, [], abort)
}

const createMemoTagConnectionQuery = `-- name: CreateMemoTagConnection :exec
INSERT INTO memo_tags(
    memo_id,
    tag
) VALUES (?, ?)
ON CONFLICT (memo_id, tag) DO NOTHING`

export interface CreateMemoTagConnectionArgs {
    memoId: string
    tag: string
}

export async function createMemoTagConnection(
    database: Database,
    args: CreateMemoTagConnectionArgs,
    abort?: AbortSignal,
) {
    await database.exec(createMemoTagConnectionQuery, [args.memoId, args.tag], abort)
}

const cleanupeMemoTagConnectionQuery = `-- name: CleanupeMemoTagConnection :many
DELETE FROM memo_tags WHERE memo_id = ?1 AND tag NOT IN (/*SLICE:tags*/?) RETURNING tag`

export interface CleanupeMemoTagConnectionArgs {
    memoId: string
    tags: string[]
}

export interface CleanupeMemoTagConnectionRow {
    tag: string
}

export async function cleanupeMemoTagConnection(
    database: Database,
    args: CleanupeMemoTagConnectionArgs,
    abort?: AbortSignal,
): Promise<CleanupeMemoTagConnectionRow[]> {
    let cleanupeMemoTagConnectionQueryWithSliceParams = cleanupeMemoTagConnectionQuery.replace(
        "/*SLICE:tags*/?",
        [...Array(args.tags.length).keys()].map((i) => `?${i + 2}`).join(","),
    )
    let result = await database.query(
        cleanupeMemoTagConnectionQueryWithSliceParams,
        [args.memoId, ...args.tags],
        abort,
    )
    return result.map((row) => mapRowToObj<CleanupeMemoTagConnectionRow>(row, {}))
}

const deleteMemoTagConnectionsQuery = `-- name: DeleteMemoTagConnections :many
DELETE FROM memo_tags WHERE memo_id = ? RETURNING tag`

export interface DeleteMemoTagConnectionsArgs {
    memoId: string
}

export interface DeleteMemoTagConnectionsRow {
    tag: string
}

export async function deleteMemoTagConnections(
    database: Database,
    args: DeleteMemoTagConnectionsArgs,
    abort?: AbortSignal,
): Promise<DeleteMemoTagConnectionsRow[]> {
    let result = await database.query(deleteMemoTagConnectionsQuery, [args.memoId], abort)
    return result.map((row) => mapRowToObj<DeleteMemoTagConnectionsRow>(row, {}))
}
