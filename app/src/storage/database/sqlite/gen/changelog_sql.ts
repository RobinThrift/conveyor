// Code generated by sqlc. DO NOT EDIT.

import type { Database } from "./db"

import { mapRowToObj, numberToBool } from "./utils"

import {
    dateFromSQLite,
    dateToSQLite,
} from "@/storage/database/sqlite/types/datetime"

const listUnsyncedChangesQuery = `-- name: ListUnsyncedChanges :many
SELECT id, public_id, source, revision, timestamp, target_type, target_id, value, is_applied, is_synced, applied_at, synced_at, created_at, updated_at
FROM changelog
WHERE
    CASE
        WHEN ?1 IS NOT NULL AND ?2 IS NOT NULL AND datetime(timestamp) = datetime(?1) THEN
             id > ?2
        WHEN ?1 IS NOT NULL THEN
            datetime(timestamp) > datetime(?1)
        ELSE true
    END
    AND is_synced = false
ORDER BY timestamp ASC, revision ASC, id ASC
LIMIT ?3`

export interface ListUnsyncedChangesArgs {
    chlgPageAfterDate: Date | undefined
    chlgPageAfterId: number | null
    pageSize: number
}

export interface ListUnsyncedChangesRow {
    id: number
    publicId: string
    source: string
    revision: number
    timestamp: Date
    targetType: string
    targetId: string
    value: any
    isApplied: boolean
    isSynced: boolean
    appliedAt: Date | undefined
    syncedAt: Date | undefined
    createdAt: Date
    updatedAt: string
}

export async function listUnsyncedChanges(
    database: Database,
    args: ListUnsyncedChangesArgs,
    abort?: AbortSignal,
): Promise<ListUnsyncedChangesRow[]> {
    let result = await database.query(
        listUnsyncedChangesQuery,
        [
            dateToSQLite(args.chlgPageAfterDate),
            args.chlgPageAfterId,
            args.pageSize,
        ],
        abort,
    )
    return result.map((row) =>
        mapRowToObj<ListUnsyncedChangesRow>(row, {
            timestamp: dateFromSQLite,
            isApplied: numberToBool,
            isSynced: numberToBool,
            appliedAt: dateFromSQLite,
            syncedAt: dateFromSQLite,
            createdAt: dateFromSQLite,
        }),
    )
}

const listUnappliedChangesQuery = `-- name: ListUnappliedChanges :many
SELECT id, public_id, source, revision, timestamp, target_type, target_id, value, is_applied, is_synced, applied_at, synced_at, created_at, updated_at
FROM changelog
WHERE
    CASE
        WHEN ?1 IS NOT NULL AND ?2 IS NOT NULL AND datetime(timestamp) = datetime(?1) THEN
             id > ?2
        WHEN ?1 IS NOT NULL THEN
            datetime(timestamp) > datetime(?1)
        ELSE true
    END
    AND is_applied = false
ORDER BY timestamp ASC, revision ASC, id ASC
LIMIT ?3`

export interface ListUnappliedChangesArgs {
    chlgPageAfterDate: Date | undefined
    chlgPageAfterId: number | null
    pageSize: number
}

export interface ListUnappliedChangesRow {
    id: number
    publicId: string
    source: string
    revision: number
    timestamp: Date
    targetType: string
    targetId: string
    value: any
    isApplied: boolean
    isSynced: boolean
    appliedAt: Date | undefined
    syncedAt: Date | undefined
    createdAt: Date
    updatedAt: string
}

export async function listUnappliedChanges(
    database: Database,
    args: ListUnappliedChangesArgs,
    abort?: AbortSignal,
): Promise<ListUnappliedChangesRow[]> {
    let result = await database.query(
        listUnappliedChangesQuery,
        [
            dateToSQLite(args.chlgPageAfterDate),
            args.chlgPageAfterId,
            args.pageSize,
        ],
        abort,
    )
    return result.map((row) =>
        mapRowToObj<ListUnappliedChangesRow>(row, {
            timestamp: dateFromSQLite,
            isApplied: numberToBool,
            isSynced: numberToBool,
            appliedAt: dateFromSQLite,
            syncedAt: dateFromSQLite,
            createdAt: dateFromSQLite,
        }),
    )
}

const listChangelogEntriesForIDQuery = `-- name: ListChangelogEntriesForID :many
SELECT id, public_id, source, revision, timestamp, target_type, target_id, value, is_applied, is_synced, applied_at, synced_at, created_at, updated_at
FROM changelog
WHERE target_id = ?
ORDER BY revision ASC, timestamp ASC`

export interface ListChangelogEntriesForIDArgs {
    targetId: string
}

export interface ListChangelogEntriesForIDRow {
    id: number
    publicId: string
    source: string
    revision: number
    timestamp: Date
    targetType: string
    targetId: string
    value: any
    isApplied: boolean
    isSynced: boolean
    appliedAt: Date | undefined
    syncedAt: Date | undefined
    createdAt: Date
    updatedAt: string
}

export async function listChangelogEntriesForID(
    database: Database,
    args: ListChangelogEntriesForIDArgs,
    abort?: AbortSignal,
): Promise<ListChangelogEntriesForIDRow[]> {
    let result = await database.query(
        listChangelogEntriesForIDQuery,
        [args.targetId],
        abort,
    )
    return result.map((row) =>
        mapRowToObj<ListChangelogEntriesForIDRow>(row, {
            timestamp: dateFromSQLite,
            isApplied: numberToBool,
            isSynced: numberToBool,
            appliedAt: dateFromSQLite,
            syncedAt: dateFromSQLite,
            createdAt: dateFromSQLite,
        }),
    )
}

const createChangelogEntryQuery = `-- name: CreateChangelogEntry :exec
INSERT INTO changelog(
    public_id,
    source,
    revision,
    timestamp,
    target_type,
    target_id,
    value,
    is_synced,
    synced_at,
    is_applied,
    applied_at
) VALUES (
    ?1,
    ?2,
    (CASE WHEN ?3 > 0 THEN
        ?3
        ELSE
        COALESCE(
            (SELECT MAX(revision) + 1 as revision FROM changelog WHERE target_type = ?4 AND target_id = ?5),
            1
        )
    END),
    ?6,
    ?4,
    ?5,
    ?7,
    ?8,
    ?9,
    ?10,
    ?11
) ON CONFLICT (public_id) DO NOTHING`

export interface CreateChangelogEntryArgs {
    publicId: string
    source: string
    revision: any | null
    targetType: string
    targetId: string
    timestamp: Date
    value: any
    isSynced: boolean
    syncedAt: Date | undefined
    isApplied: boolean
    appliedAt: Date | undefined
}

export async function createChangelogEntry(
    database: Database,
    args: CreateChangelogEntryArgs,
    abort?: AbortSignal,
) {
    await database.exec(
        createChangelogEntryQuery,
        [
            args.publicId,
            args.source,
            args.revision,
            args.targetType,
            args.targetId,
            dateToSQLite(args.timestamp),
            args.value,
            args.isSynced,
            dateToSQLite(args.syncedAt),
            args.isApplied,
            dateToSQLite(args.appliedAt),
        ],
        abort,
    )
}

const markChangelogEntriesAsSyncedQuery = `-- name: MarkChangelogEntriesAsSynced :exec
UPDATE changelog
SET is_synced = TRUE, synced_at = COALESCE(synced_at, strftime('%Y-%m-%d %H:%M:%SZ', CURRENT_TIMESTAMP))
WHERE public_id IN (/*SLICE:public_ids*/?)`

export interface MarkChangelogEntriesAsSyncedArgs {
    publicIds: string[]
}

export async function markChangelogEntriesAsSynced(
    database: Database,
    args: MarkChangelogEntriesAsSyncedArgs,
    abort?: AbortSignal,
) {
    let markChangelogEntriesAsSyncedQueryWithSliceParams =
        markChangelogEntriesAsSyncedQuery.replace(
            "/*SLICE:public_ids*/?",
            [...Array(args.publicIds.length).keys()]
                .map((i) => `?${i + 1}`)
                .join(","),
        )
    await database.exec(
        markChangelogEntriesAsSyncedQueryWithSliceParams,
        [...args.publicIds],
        abort,
    )
}

const markChangelogEntriesAsAppliedQuery = `-- name: MarkChangelogEntriesAsApplied :exec
UPDATE changelog
SET is_applied = TRUE, applied_at = COALESCE(applied_at, strftime('%Y-%m-%d %H:%M:%SZ', CURRENT_TIMESTAMP))
WHERE public_id IN (/*SLICE:public_ids*/?)`

export interface MarkChangelogEntriesAsAppliedArgs {
    publicIds: string[]
}

export async function markChangelogEntriesAsApplied(
    database: Database,
    args: MarkChangelogEntriesAsAppliedArgs,
    abort?: AbortSignal,
) {
    let markChangelogEntriesAsAppliedQueryWithSliceParams =
        markChangelogEntriesAsAppliedQuery.replace(
            "/*SLICE:public_ids*/?",
            [...Array(args.publicIds.length).keys()]
                .map((i) => `?${i + 1}`)
                .join(","),
        )
    await database.exec(
        markChangelogEntriesAsAppliedQueryWithSliceParams,
        [...args.publicIds],
        abort,
    )
}

const deleteChangelogEntryQuery = `-- name: DeleteChangelogEntry :exec
DELETE FROM changelog WHERE public_id = ?`

export interface DeleteChangelogEntryArgs {
    publicId: string
}

export async function deleteChangelogEntry(
    database: Database,
    args: DeleteChangelogEntryArgs,
    abort?: AbortSignal,
) {
    await database.exec(deleteChangelogEntryQuery, [args.publicId], abort)
}
