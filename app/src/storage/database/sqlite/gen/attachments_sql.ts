// Code generated by sqlc. DO NOT EDIT.

import type { Database } from "./db"

import { mapRowToObj } from "./utils"

import { dateFromSQLite } from "@/storage/database/sqlite/types/datetime"

const getAttachmentQuery = `-- name: GetAttachment :one
SELECT
    attachments.id, attachments.public_id, attachments.filepath, attachments.original_filename, attachments.content_type, attachments.size_bytes, attachments.sha256, attachments.created_at
FROM attachments
WHERE public_id = ?
LIMIT 1`

export interface GetAttachmentArgs {
    publicId: string
}

export interface GetAttachmentRow {
    id: number
    publicId: string
    filepath: string
    originalFilename: string
    contentType: string
    sizeBytes: any
    sha256: Uint8Array<ArrayBufferLike>
    createdAt: Date
}

export async function getAttachment(
    database: Database,
    args: GetAttachmentArgs,
    abort?: AbortSignal,
): Promise<GetAttachmentRow | null> {
    let result = await database.queryOne(
        getAttachmentQuery,
        [args.publicId],
        abort,
    )
    if (result === undefined) {
        return null
    }
    return mapRowToObj<GetAttachmentRow>(result, { createdAt: dateFromSQLite })
}

const getAttachmentByFilepathQuery = `-- name: GetAttachmentByFilepath :one
SELECT
    attachments.id, attachments.public_id, attachments.filepath, attachments.original_filename, attachments.content_type, attachments.size_bytes, attachments.sha256, attachments.created_at
FROM attachments
WHERE filepath = ?
LIMIT 1`

export interface GetAttachmentByFilepathArgs {
    filepath: string
}

export interface GetAttachmentByFilepathRow {
    id: number
    publicId: string
    filepath: string
    originalFilename: string
    contentType: string
    sizeBytes: any
    sha256: Uint8Array<ArrayBufferLike>
    createdAt: Date
}

export async function getAttachmentByFilepath(
    database: Database,
    args: GetAttachmentByFilepathArgs,
    abort?: AbortSignal,
): Promise<GetAttachmentByFilepathRow | null> {
    let result = await database.queryOne(
        getAttachmentByFilepathQuery,
        [args.filepath],
        abort,
    )
    if (result === undefined) {
        return null
    }
    return mapRowToObj<GetAttachmentByFilepathRow>(result, {
        createdAt: dateFromSQLite,
    })
}

const countAttachmentsQuery = `-- name: CountAttachments :one
SELECT COUNT(*) FROM attachments`

export interface CountAttachmentsRow {
    count: number
}

export async function countAttachments(
    database: Database,
    abort?: AbortSignal,
): Promise<CountAttachmentsRow | null> {
    let result = await database.queryOne(countAttachmentsQuery, [], abort)
    if (result === undefined) {
        return null
    }
    return mapRowToObj<CountAttachmentsRow>(result, {})
}

const listAttachmentsQuery = `-- name: ListAttachments :many
SELECT
    attachments.id, attachments.public_id, attachments.filepath, attachments.original_filename, attachments.content_type, attachments.size_bytes, attachments.sha256, attachments.created_at
FROM attachments
WHERE original_filename > ?1
ORDER BY original_filename
LIMIT ?2`

export interface ListAttachmentsArgs {
    pageAfter: string
    pageSize: number
}

export interface ListAttachmentsRow {
    id: number
    publicId: string
    filepath: string
    originalFilename: string
    contentType: string
    sizeBytes: any
    sha256: Uint8Array<ArrayBufferLike>
    createdAt: Date
}

export async function listAttachments(
    database: Database,
    args: ListAttachmentsArgs,
    abort?: AbortSignal,
): Promise<ListAttachmentsRow[]> {
    let result = await database.query(
        listAttachmentsQuery,
        [args.pageAfter, args.pageSize],
        abort,
    )
    return result.map((row) =>
        mapRowToObj<ListAttachmentsRow>(row, { createdAt: dateFromSQLite }),
    )
}

const createAttachmentQuery = `-- name: CreateAttachment :one
INSERT INTO attachments(
    public_id,
    filepath,
    original_filename,
    content_type,
    size_bytes,
    sha256
) VALUES (?, ?, ?, ?, ?, ?)
RETURNING attachments.public_id`

export interface CreateAttachmentArgs {
    publicId: string
    filepath: string
    originalFilename: string
    contentType: string
    sizeBytes: any
    sha256: Uint8Array<ArrayBufferLike>
}

export interface CreateAttachmentRow {
    publicId: string
}

export async function createAttachment(
    database: Database,
    args: CreateAttachmentArgs,
    abort?: AbortSignal,
): Promise<CreateAttachmentRow | null> {
    let result = await database.queryOne(
        createAttachmentQuery,
        [
            args.publicId,
            args.filepath,
            args.originalFilename,
            args.contentType,
            args.sizeBytes,
            args.sha256,
        ],
        abort,
    )
    if (result === undefined) {
        return null
    }
    return mapRowToObj<CreateAttachmentRow>(result, {})
}

const deleteAttachmentsQuery = `-- name: DeleteAttachments :execrows
DELETE FROM attachments WHERE public_id IN (/*SLICE:ids*/?)`

export interface DeleteAttachmentsArgs {
    ids: string[]
}

export async function deleteAttachments(
    database: Database,
    args: DeleteAttachmentsArgs,
    abort?: AbortSignal,
) {
    let deleteAttachmentsQueryWithSliceParams = deleteAttachmentsQuery.replace(
        "/*SLICE:ids*/?",
        [
            ...Array(args.ids.length)
                .keys()
                .map((i) => `?${i + 1}`),
        ].join(","),
    )
    return database.exec(
        deleteAttachmentsQueryWithSliceParams,
        [...args.ids],
        abort,
    )
}

const listAttachmentsForMemoQuery = `-- name: ListAttachmentsForMemo :many
SELECT attachments.id, attachments.public_id, attachments.filepath, attachments.original_filename, attachments.content_type, attachments.size_bytes, attachments.sha256, attachments.created_at
FROM attachments
JOIN memo_attachments ON memo_attachments.attachment_id = attachments.public_id
WHERE memo_attachments.memo_id = ?`

export interface ListAttachmentsForMemoArgs {
    memoId: string
}

export interface ListAttachmentsForMemoRow {
    id: number
    publicId: string
    filepath: string
    originalFilename: string
    contentType: string
    sizeBytes: any
    sha256: Uint8Array<ArrayBufferLike>
    createdAt: Date
}

export async function listAttachmentsForMemo(
    database: Database,
    args: ListAttachmentsForMemoArgs,
    abort?: AbortSignal,
): Promise<ListAttachmentsForMemoRow[]> {
    let result = await database.query(
        listAttachmentsForMemoQuery,
        [args.memoId],
        abort,
    )
    return result.map((row) =>
        mapRowToObj<ListAttachmentsForMemoRow>(row, {
            createdAt: dateFromSQLite,
        }),
    )
}

const createMemoAttachmentLinkQuery = `-- name: CreateMemoAttachmentLink :exec
INSERT INTO memo_attachments(
    memo_id,
    attachment_id
) VALUES (?, ?)`

export interface CreateMemoAttachmentLinkArgs {
    memoId: string
    attachmentId: string
}

export async function createMemoAttachmentLink(
    database: Database,
    args: CreateMemoAttachmentLinkArgs,
    abort?: AbortSignal,
) {
    await database.exec(
        createMemoAttachmentLinkQuery,
        [args.memoId, args.attachmentId],
        abort,
    )
}

const deleteAllMemoAttachmentLinksQuery = `-- name: DeleteAllMemoAttachmentLinks :exec
DELETE FROM memo_attachments WHERE memo_id = ?`

export interface DeleteAllMemoAttachmentLinksArgs {
    memoId: string
}

export async function deleteAllMemoAttachmentLinks(
    database: Database,
    args: DeleteAllMemoAttachmentLinksArgs,
    abort?: AbortSignal,
) {
    await database.exec(deleteAllMemoAttachmentLinksQuery, [args.memoId], abort)
}

const deleteMemoAttachmentLinksQuery = `-- name: DeleteMemoAttachmentLinks :exec
DELETE FROM memo_attachments WHERE memo_id = ? AND attachment_id IN (/*SLICE:attachment_ids*/?)`

export interface DeleteMemoAttachmentLinksArgs {
    memoId: string
    attachmentIds: string[]
}

export async function deleteMemoAttachmentLinks(
    database: Database,
    args: DeleteMemoAttachmentLinksArgs,
    abort?: AbortSignal,
) {
    let deleteMemoAttachmentLinksQueryWithSliceParams =
        deleteMemoAttachmentLinksQuery.replace(
            "/*SLICE:attachment_ids*/?",
            [
                ...Array(args.attachmentIds.length)
                    .keys()
                    .map((i) => `?${i + 2}`),
            ].join(","),
        )
    await database.exec(
        deleteMemoAttachmentLinksQueryWithSliceParams,
        [args.memoId, ...args.attachmentIds],
        abort,
    )
}

const listUnusedAttachmentsQuery = `-- name: ListUnusedAttachments :many
SELECT attachments.id, attachments.public_id, attachments.filepath, attachments.original_filename, attachments.content_type, attachments.size_bytes, attachments.sha256, attachments.created_at
FROM attachments
LEFT JOIN memo_attachments ON attachments.id = memo_attachments.attachment_id
WHERE memo_attachments.id IS NULL`

export interface ListUnusedAttachmentsRow {
    id: number
    publicId: string
    filepath: string
    originalFilename: string
    contentType: string
    sizeBytes: any
    sha256: Uint8Array<ArrayBufferLike>
    createdAt: Date
}

export async function listUnusedAttachments(
    database: Database,
    abort?: AbortSignal,
): Promise<ListUnusedAttachmentsRow[]> {
    let result = await database.query(listUnusedAttachmentsQuery, [], abort)
    return result.map((row) =>
        mapRowToObj<ListUnusedAttachmentsRow>(row, {
            createdAt: dateFromSQLite,
        }),
    )
}
